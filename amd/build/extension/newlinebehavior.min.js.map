{"version":3,"file":"newlinebehavior.min.js","sources":["../../src/extension/newlinebehavior.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_ibwidgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n/**\n * @param {string | undefined} content\n * @returns {string}\n */\nexport function removeEmptyParagraphs(content) {\n    if (!content) {\n        return '';\n    }\n\n    // Otherwise, use DOMParser for safety\n    try {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(content, 'text/html');\n        doc.querySelectorAll('p').forEach(p => {\n            if (p.closest('pre, code, script')) {\n                return;\n            }\n\n            // Consider empty if contains only:\n            // - comments\n            // - whitespace text nodes\n            // - empty elements (like <span></span>)\n            const isEmpty = Array.from(p.childNodes).every(node => {\n                if (node.nodeType === Node.COMMENT_NODE) {\n                    return true;\n                }\n                if (node.nodeType === Node.TEXT_NODE) {\n                    return !node.textContent?.trim();\n                } else if (node.nodeType === Node.ELEMENT_NODE) {\n                    // @ts-ignore\n                    if (node.tagName === 'SPAN' && node.attributes.length === 0) {\n                        return !node.textContent?.trim();\n                    }\n                    return false;\n                }\n                return false;\n            });\n\n            if (isEmpty) {\n                p.remove();\n            }\n        });\n        return doc.body.innerHTML;\n    } catch (err) {\n        // Fallback: regex (less safe)\n        return content.replace(/<p>\\s*<\\/p>/gi, '');\n    }\n}\n\n\n/**\n * @param {string | undefined} content\n * @param {string} [padWith]\n * @returns {string}\n */\nexport function padEmptyParagraphsWith(content, padWith = '<br>') {\n    if (!content) {\n        return '';\n    }\n\n    // Quick regex optimization only if content cannot contain comments, scripts, pre, code\n    if (!/[<](script|pre|code|!--)/i.test(content)) {\n        return content.replace(/<p>\\s*<\\/p>/gi, `<p>${padWith}</p>`);\n    }\n\n    try {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(content, 'text/html');\n\n        doc.querySelectorAll('p').forEach(p => {\n            if (p.closest('pre, code, script')) {\n                return;\n            }\n\n            // Consider paragraph empty if it contains only comments or whitespace text\n            const isEmpty = Array.from(p.childNodes).every(node => {\n                if (node.nodeType === Node.COMMENT_NODE) {\n                    return true;\n                }\n                if (node.nodeType === Node.TEXT_NODE) {\n                    return !node.textContent?.trim();\n                }\n                return false; // Any element (including <br>) counts as content\n            });\n\n            if (isEmpty) {\n                const comments = Array.from(p.childNodes)\n                    .filter(n => n.nodeType === Node.COMMENT_NODE)\n                    .map(n => {\n                        if (n.nodeType === Node.COMMENT_NODE) {\n                            // @ts-ignore\n                            return `<!--${n.data}-->`;\n                        }\n                        return '';\n                    })\n                    .join('');\n                p.innerHTML = `${padWith}${comments}`;\n            }\n        });\n\n        return doc.body.innerHTML;\n    } catch (err) {\n        // Fallback: regex (less safe)\n        return content.replace(/<p>\\s*<\\/p>/gi, `<p>${padWith}</p>`);\n    }\n}\n\n/**\n *\n * @param {import(\"../plugin\").TinyMCE} editor\n */\nexport function emulateAttoNewlineBehaviour(editor) {\n    // Monkey patch setContent to have control over empty lines\n    if (!editor._orgSetContent) {\n        editor._orgSetContent = editor.setContent;\n\n        editor.setContent = function(/** @type {string} */ content, /** @type {*} */ args) {\n            // Only process content for the first call\n            let processedContent = content;\n            try {\n                if (!args || args.format === 'html') {\n                    processedContent = removeEmptyParagraphs(content);\n                }\n            } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn('setContent patch failed', err);\n            }\n            return editor._orgSetContent.call(this, processedContent, args);\n        };\n    }\n\n    if (!editor._orgGetContent) {\n        editor._orgGetContent = editor.getContent;\n\n        editor.getContent = function(/** @type {any} */ args) {\n            let content = editor._orgGetContent.call(this, args) || '';\n            try {\n                // Convert empty <p></p> to <p><br></p> for Atto compatibility\n                content = padEmptyParagraphsWith(content);\n            } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn('getContent patch failed', err);\n            }\n            return content;\n        };\n    }\n}\n\n/**\n * @param {import(\"../plugin\").TinyMCE} editor\n * @param {string|number} cfgLevel - Si cfgLevel=1, evita scroll i no fa res més,\n *                                   si cfgLevel=2 evita scroll i posiciona en element més proper.\n */\nexport function avoidScrollNonEditableZones(editor, cfgLevel) {\n\n    editor.on('mousedown', function(/** @type {MouseEvent} */ e) {\n        // Només actuem en clic esquerre\n        if (e.button !== 0) {\n            return;\n        }\n        const body = editor.getBody();\n        const html = body.parentElement;\n\n        // Sortim si el clic no és dins del body\n        if ((e.target !== html && e.target !== body) && !body.contains(e.target)) {\n            return;\n        }\n\n        // Ara podem tractar el cas “clic en zona buida” (target === body)\n        if (e.target === body || e.target == html) {\n            // Sortim si el body és buit\n            if (body.children.length === 0) {\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n\n            const rng = editor.selection.getRng();\n\n            // Si l'editor no té focus, el posem\n            if (!editor.hasFocus()) {\n                // Get current scroll\n                const scrollTop = html.scrollTop;\n                const scrollLeft = html.scrollLeft;\n                editor.focus();\n                // Restore scroll\n                requestAnimationFrame(() => {\n                    html.scrollTop = scrollTop;\n                    html.scrollLeft = scrollLeft;\n                });\n            }\n\n            if (Number(cfgLevel) === 2) {\n                if (rng && rng.startContainer) {\n                    // Range existent → restaurar-lo\n                    editor.selection.setRng(rng);\n                }\n            }\n        }\n\n    });\n}\n"],"names":["removeEmptyParagraphs","content","doc","DOMParser","parseFromString","querySelectorAll","forEach","p","closest","Array","from","childNodes","every","node","nodeType","Node","COMMENT_NODE","TEXT_NODE","textContent","_node$textContent","trim","ELEMENT_NODE","tagName","attributes","length","_node$textContent2","remove","body","innerHTML","err","replace","padEmptyParagraphsWith","padWith","test","_node$textContent3","comments","filter","n","map","data","join","editor","cfgLevel","on","e","button","getBody","html","parentElement","target","contains","children","preventDefault","stopPropagation","rng","selection","getRng","hasFocus","scrollTop","scrollLeft","focus","requestAnimationFrame","Number","startContainer","setRng","_orgSetContent","setContent","args","processedContent","format","console","warn","call","this","_orgGetContent","getContent"],"mappings":";;;;;;;;SA0BgBA,sBAAsBC,aAC7BA,cACM,aAMDC,KADS,IAAIC,WACAC,gBAAgBH,QAAS,oBAC5CC,IAAIG,iBAAiB,KAAKC,SAAQC,OAC1BA,EAAEC,QAAQ,4BAQEC,MAAMC,KAAKH,EAAEI,YAAYC,OAAMC,cACvCA,KAAKC,WAAaC,KAAKC,eAGvBH,KAAKC,WAAaC,KAAKE,sCACfJ,KAAKK,0CAALC,kBAAkBC,QACnBP,KAAKC,WAAaC,KAAKM,eAET,SAAjBR,KAAKS,SAAiD,IAA3BT,KAAKU,WAAWC,qCACnCX,KAAKK,2CAALO,mBAAkBL,uDAQlCb,EAAEmB,YAGHxB,IAAIyB,KAAKC,UAClB,MAAOC,YAEE5B,QAAQ6B,QAAQ,gBAAiB,cAUhCC,uBAAuB9B,aAAS+B,+DAAU,WACjD/B,cACM,OAIN,4BAA4BgC,KAAKhC,gBAC3BA,QAAQ6B,QAAQ,gBAAkB,MAAKE,yBAKxC9B,KADS,IAAIC,WACAC,gBAAgBH,QAAS,oBAE5CC,IAAIG,iBAAiB,KAAKC,SAAQC,OAC1BA,EAAEC,QAAQ,+BAKEC,MAAMC,KAAKH,EAAEI,YAAYC,OAAMC,cACvCA,KAAKC,WAAaC,KAAKC,cAGvBH,KAAKC,WAAaC,KAAKE,wCACfJ,KAAKK,2CAALgB,mBAAkBd,kCAKrB,OACHe,SAAW1B,MAAMC,KAAKH,EAAEI,YACzByB,QAAOC,GAAKA,EAAEvB,WAAaC,KAAKC,eAChCsB,KAAID,GACGA,EAAEvB,WAAaC,KAAKC,aAEZ,UAAMqB,EAAEE,aAEb,KAEVC,KAAK,IACVjC,EAAEqB,UAAa,GAAEI,UAAUG,eAI5BjC,IAAIyB,KAAKC,UAClB,MAAOC,YAEE5B,QAAQ6B,QAAQ,gBAAkB,MAAKE,sHAkDVS,OAAQC,UAEhDD,OAAOE,GAAG,aAAa,SAAmCC,MAErC,IAAbA,EAAEC,oBAGAlB,KAAOc,OAAOK,UACdC,KAAOpB,KAAKqB,kBAGbJ,EAAEK,SAAWF,MAAQH,EAAEK,SAAWtB,MAAUA,KAAKuB,SAASN,EAAEK,WAK7DL,EAAEK,SAAWtB,MAAQiB,EAAEK,QAAUF,MAAM,IAEV,IAAzBpB,KAAKwB,SAAS3B,cAGlBoB,EAAEQ,iBACFR,EAAES,wBAEIC,IAAMb,OAAOc,UAAUC,aAGxBf,OAAOgB,WAAY,OAEdC,UAAYX,KAAKW,UACjBC,WAAaZ,KAAKY,WACxBlB,OAAOmB,QAEPC,uBAAsB,KAClBd,KAAKW,UAAYA,UACjBX,KAAKY,WAAaA,cAID,IAArBG,OAAOpB,WACHY,KAAOA,IAAIS,gBAEXtB,OAAOc,UAAUS,OAAOV,wDApFAb,QAEnCA,OAAOwB,iBACRxB,OAAOwB,eAAiBxB,OAAOyB,WAE/BzB,OAAOyB,WAAa,SAA+BjE,QAA0BkE,UAErEC,iBAAmBnE,YAEdkE,MAAwB,SAAhBA,KAAKE,SACdD,iBAAmBpE,sBAAsBC,UAE/C,MAAO4B,KAELyC,QAAQC,KAAK,0BAA2B1C,YAErCY,OAAOwB,eAAeO,KAAKC,KAAML,iBAAkBD,QAI7D1B,OAAOiC,iBACRjC,OAAOiC,eAAiBjC,OAAOkC,WAE/BlC,OAAOkC,WAAa,SAA4BR,UACxClE,QAAUwC,OAAOiC,eAAeF,KAAKC,KAAMN,OAAS,OAGpDlE,QAAU8B,uBAAuB9B,SACnC,MAAO4B,KAELyC,QAAQC,KAAK,0BAA2B1C,YAErC5B"}